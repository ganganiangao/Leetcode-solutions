# 516_longest-palindromic-subsequence


### 提示：

想像你要找的是在字串 `s` 中，**可以跳過一些字元，但順序不能改變** 的最長回文子序列。

所以可以從兩個方向思考：

> **如果你知道 `s[i+1..j-1]` 的最長回文子序列長度，能不能用來推出 `s[i..j]` 呢？**

你可以建立一個 `dp[i][j]` 表示 **s\[i..j] 之間的最長回文子序列長度**，接著從小區間開始填表。

很好，我們就針對這個關鍵點來給你**進一步提示**：

---

### ✅ 關鍵邏輯提示：

* 假設你現在處理的是區間 `s[i..j]`，那你要看：

  * **s\[i] 和 s\[j] 是否相等？**

---

### 分兩種情況來看：

1. **如果 `s[i] == s[j]`**：

   那這兩個字元可以包住中間的回文，所以：

   ```
   dp[i][j] = dp[i+1][j-1] + 2
   ```

   👉 因為你可以把 `s[i]` 和 `s[j]` 加在中間那段回文子序列的兩端。

2. **如果 `s[i] != s[j]`**：

   那你不能同時選 `s[i]` 和 `s[j]`，只能選一邊開始，所以：

   ```
   dp[i][j] = max(dp[i+1][j], dp[i][j-1])
   ```

   👉 表示你要嘛略過 `s[i]`，要嘛略過 `s[j]`，看哪邊能構成比較長的回文子序列。

---

### 額外小建議：

因為 `dp[i][j]` 依賴的是 `dp[i+1][j-1]`、`dp[i+1][j]`、`dp[i][j-1]`，所以填表時記得要：

* 先處理小區間（像長度 1、2...）
* 然後再處理大區間（長度越長越往右上角填）

---

可以自己試著手動寫出 `dp[i][j]` 表格填法，或用 "bbbab" 這種範例跑一次就很直觀。


![image](https://github.com/user-attachments/assets/639c4658-4443-4924-b0e3-5bd6571de27e)

